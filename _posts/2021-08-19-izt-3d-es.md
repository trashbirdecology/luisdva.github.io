---
title: "Mapas tridimensionales en R"
excerpt: Utilizando el paquete rayshader para generar mapas fotorealistas a partir de objectos ggplot.
tagline: "Georeferenciando mapas desde ggplot2 para renderizar en 3D"
category: rstats
tags:
  - rspatiales
  - SIG
  - rayshader
  - rayrender
  - 3D
  - gafas
header:
  overlay_image: /assets/images/featureMatrixInd.jpg
  overlay_filter: 0.4

---
> English-language version [here](https://luisdva.github.io/rstats/izt-3d/)

Hoy en d√≠a ya es posible y adem√°s relativamente f√°cil renderizar (anglicismo para describir el proceso de generar im√°genes digitales a partir de un modelo tridimensional) mapas con perspectiva e iluminaci√≥n usando R. Gracias a los paquetes `rayshader` y` rayrender`, desarrollados por [Tyler Morgan-Wall](https://www.tylermw.com/){:target="_blank"} y `elevatr` de [Jeff Hollister](https://jwhollister.com/){:target="_blank"}, podemos combinar una imagen georeferenciada con un modelo de elevaci√≥n digital (DEM, por sus siglas en ingl√©s) para darle profundidad y ambiente a cualquier mapa que tengamos en formato digital.
<br/>

El tuitero [@flotsam](https://twitter.com/researchremora){:target="_blank"} siempre comparte ejemplos muy buenos, como √©ste que subi√≥ hace poco:

<blockquote class="twitter-tweet" data-dnt="true"><p lang="en" dir="ltr">A 1972 NRCan (formerly the Department of Energy, Mines, and Resources) map of Montr√©al, Canada. Spent more time trying to decipher cryptic filenames to find what I want than actually rayshading it. :P<a href="https://twitter.com/hashtag/rayshader?src=hash&amp;ref_src=twsrc%5Etfw">#rayshader</a> adventures, an <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> tale <a href="https://t.co/O756ddhs9G">pic.twitter.com/O756ddhs9G</a></p>&mdash; flotsam (@researchremora) <a href="https://twitter.com/researchremora/status/1422177343645302785?ref_src=twsrc%5Etfw">August 2, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br/>

El proceso para _renderizar_ imagenes georeferencias est√° resumido en esta [gu√≠a](https://gist.github.com/tylermorganwall/cec09392cb7d3e102496e30afe5e0898){:target="_blank"}. 
  
Hay muchos mapas ya georeferenciados en Internet, y adem√°s podemos usar programas de SIG para empatar cualquier mapa digital con su contexto espacial mediante puntos de control. Yo generalmente prefiero hacer mis propios mapa en `ggplot2` y quer√≠a procesarlos en 3D con `rayshader`. 

Cuando hacemos mapas en `ggplot2` con los paquetes geoespaciales m√°s populares (`sf`, `stars`, etc.), ya tenemos datos espaciales y no har√≠a falta asignarle a mano coordenadas del mundo real a cada pixel del raster de nuestro mapa. Adem√°s, cada que trato de georeferenciar im√°genes en qGIS pierdo la paciencia por tener que crear al menos seis puntos de control con el cursor y la mano toda temblorina.

<figure>
    <a href="/assets/images/memazorast.jpg"><img src="/assets/images/memazorast.jpg" width= "660"></a>
        <figcaption></figcaption>
</figure>
<br/>

En esta [respuesta de StackOverflow](https://stackoverflow.com/questions/53771331/writing-a-path-route-plot-as-a-geotiff-in-r
){:target="_blank"}, nos explican como extraer la informaci√≥n que describe los valores xy m√°ximos y m√≠nimos del panel de un objeto ggplot, para poder asignarle esta extensi√≥n a la versi√≥n raster que ya exportamos de nuestro objeto.

Para poder seguir este m√©todo, lo importante es asegurarse que el objeto de ggplot no tenga nada de bordes, para que los valores xy que definen su extensi√≥n empaten con los bordes de la imagen que exportamos con el fin de usarla en `rayshader`. Para lograrlo, usamos el (`theme_nothing`) que viene con el paquete `cowplot` de [Claus Wilke](https://clauswilke.com/){:target="_blank"}. En resumen, √©sto equivale a apagar casi todos los elementos de la figura y en no tener ninguna expansi√≥n de los ejes. [Aqu√≠](https://stackoverflow.com/questions/31254533/when-using-ggplot-in-r-how-do-i-remove-margins-surrounding-the-plot-area/31255629){:target="_blank"} podemos ver cu√°les elementos se est√°n modificando.


Probemos. Este ejemplo est√° basado en datos espaciales del portal de datos geogr√°ficos de la [CONABIO](http://www.conabio.gob.mx/informacion/gis/){:target="_blank"} y de la [CONANP](http://sig.conanp.gob.mx/website/pagsig/info_shape.htm){:target="_blank"}. Descargu√© los shapefiles de √Åreas Naturales Protegidas y de Uso del suelo y vegetaci√≥n (escala 1:250000, serie VI continuo nacional), y me enfoqu√© en la ANP Iztacc√≠huatl-Popocat√©petl. 

Estos pasos cargan los archivos shp, recortan los datos a la ANP de inter√©s, y agrupan (medio arbitrariamente) algunas de las categor√≠as de uso de suelo y vegetaci√≥n. Luego, podemos hacer un mapa simple pero colorido de los volcanes. Aqu√≠ el `theme_nothing()` le quita los m√°rgenes y los r√≥tulos de los ejes a la figura, y hay algunos argumentos de `coord_sf()` que son para que todo quede dentro del panel principal de la figura.

{% highlight r %}
# paquetes
library(sf)        # CRAN v0.9-8
library(dplyr)     # CRAN v1.0.7
library(stringr)   # CRAN v1.4.0
library(ggplot2)   # CRAN v3.3.3
library(raster)    # CRAN v3.4-13
library(stars)     # [github::r-spatial/stars] v0.5-3
library(elevatr)   # CRAN v0.4.1
library(rayshader) # [github::tylermorganwall/rayshader] v0.26.1
library(smoothr)   # CRAN v0.2.2

# importar ANPs 
anps <- st_read("YOUR-PATH-HERE/182ANP_Geo_ITRF08_Agosto_2020.shp") %>%
  dplyr::select(NOMBRE)

# importar vegetaci√≥n
veg <- st_read("YOUR-PATH-HERE/usv250s6gw.shp") %>%
  st_transform(st_crs(anps))

# area de estudio
izta <- anps %>% filter(str_detect(NOMBRE, "Izt"))

# limites
Iztbbox <- st_buffer(izta, dist = 0.1) %>%
  st_bbox() %>%
  st_as_sfc()

# disolver vegetaci√≥n
veggr <- veg %>%
  group_by(CVE_UNION) %>%
  summarize(.groups = "keep")

# recortar a los limites
Iztveg <- st_crop(veggr, Iztbbox)

# reclasificar vegetaci√≥n
Iztvegrc <- Iztveg %>% mutate(vegclass = case_when(
  str_detect(CVE_UNION, "^B") ~ "Bosque",
  str_detect(CVE_UNION, "^VS") ~ "Vegetaci√≥n secundaria",
  str_detect(CVE_UNION, "^T") ~ "Agricultura (temporal)",
  str_detect(CVE_UNION, "^R") ~ "Agricultura (Riego)",
  str_detect(CVE_UNION, "DV") ~ "Sin vegetaci√≥n",
  str_detect(CVE_UNION, "^P") ~ "Pastizal",
  str_detect(CVE_UNION, "VW") ~ "Pradera de alta monta√±a",
  TRUE ~ CVE_UNION
))

# smooth
Iztvegrc <- smooth(Iztvegrc)

# exportando a tiff
ragg::agg_tiff(
  filename = "izt.tiff",
  res = 400, width = 3.88, height = 5.92, units = "in"
)
# figura
iztgg <-
  ggplot() +
  geom_sf(data = Iztvegrc, aes(fill = vegclass), size = 0) +
  scale_fill_manual(values = c(
    "#b5c99a", "#97a97c", "#8d99ae", "#26432F",
    "#e8e8e4", "#cdeac0", "#B1D5BB",
    "#cde5d7", "#adb6c4", "#9cc5a1",
    "#ffc49b", "#eaeaea", "#f3e7e4"
  ), guide = FALSE) +
  ggfx::with_outer_glow(geom_sf(data = izta, fill = "transparent", color = "white", size = 0.1),
    expand = 3, colour = "white"
  ) +
  coord_sf(expand = FALSE, clip = "on") +
  cowplot::theme_nothing() +
  theme(
    panel.grid.major = element_line(color = "#14213d", size = 0.1, linetype = "dashed"),
    panel.ontop = TRUE
  )

iztgg

dev.off()
{% endhighlight %}

Me tom√≥ algunos intentos poder exportar el tiff sin que saliera espacio en blanco en los m√°rgenes, pero cuando √©sto ya queda podemos importar la imagen usando el paquete `raster`.

<figure>
    <a href="/assets/images/iztgg.png"><img src="/assets/images/iztgg.png"></a>
        <figcaption>Se ve bien</figcaption>
</figure>
<br/>

Revisemos ese tiff.

{% highlight r %}
# creando un StackedRaster 
stackedRaster <- raster::stack("izt.tiff")
{% endhighlight %}

<figure>
    <a href="/assets/images/tiffrgb.png"><img src="/assets/images/tiffrgb.png" width= "660"></a>
        <figcaption>Raster RGB</figcaption>
</figure>
<br/>

La informaci√≥n geoespacial que necesitamos est√° contenida en el objeto ggplot, y la podemos extraer con `ggplot_build`. Uno de los componentes del objeto es una lista con los m√°ximos y m√≠nimos para x y para y, y √©stos se los damos a la funci√≥n `extent` para georeferenciar el mapa (tambi√©n hay que definir la proyecci√≥n). El raster georeferenciado se exporta con `INT1U` para que los valores queden entre 0 y 255, y `PHOTOMETRIC=RGB` para declarar c√≥mo se interpretan los colores.

{% highlight r %}
# extraer componentes Geoepaciales
lat_long <- ggplot_build(iztgg)$layout$panel_params[[1]][c("x_range", "y_range")]

# asignarle los valores al StackedRaster
raster::extent(stackedRaster) <- c(lat_long$x_range, lat_long$y_range)
raster::projection(stackedRaster) <- raster::crs(st_crs(Iztvegrc)$proj4string)

# exportar
writeRaster(stackedRaster, "iztGeoTiff.tif", options = "PHOTOMETRIC=RGB", datatype = "INT1U", overwrite = TRUE)

{% endhighlight %}

Importamos de nuevo el geoTiff

{% highlight r %}
grRast <- raster::brick("iztGeoTiff.tif")
grRastst <- raster::stack(grRast)
{% endhighlight %}


Ahora ya podemos seguir las gu√≠as existentes para procesar im√°genes con `rayshader`. Primero hay que transformar el raster en un array (arreglo de valores num√©ricos), y usar este objeto para descargar datos de elevaci√≥n mediante `elevatr`. Luego los recortamos, les reducimos la resoluci√≥n y el tama√±o, y los transponemos (los rasters y los arreglos num√©ricos vienen con orientaciones distintas en R).

{% highlight r %}

# convertir en array
test_c_arr <- as.array(grRastst)

# descargar elevaci√≥n
Rch_dem <- elevatr::get_elev_raster(grRastst, z = 9)
Rch_dem <- raster::crop(Rch_dem, grRastst)
plot(Rch_dem)

# reducir tama√±o
areademMatrix <- rayshader::resize_matrix(rayshader::raster_to_matrix(Rch_dem), scale = 0.7)

# transponer
demFinal <- (areademMatrix)
{% endhighlight %}

As√≠ se ve el DEM.

<figure>
    <a href="/assets/images/iztdem.png"><img src="/assets/images/iztdem.png" width= "660"></a>
        <figcaption>DEM</figcaption>
</figure>
<br/>

Ahora calculamos el sombreado y combinamos el arreglo con los datos de elevaci√≥n.

{% highlight r %}
# Sombreado
ambient_layer <- ambient_shade(demFinal, zscale = 10, multicore = TRUE, maxsearch = 200)
ray_layer <- ray_shade(demFinal, zscale = 20, multicore = TRUE)

# 3D
(test_c_arr / 255) %>%
  add_shadow(ray_layer, 0.3) %>%
  add_shadow(ambient_layer, 0) %>%
  plot_3d(demFinal,
    zscale = 150, theta = -50, phi = 28, zoom = 0.3,
    windowsize = c(1200, 800), solid = FALSE,
    background = "#3d314a"
  )
{% endhighlight %}

As√≠ se ve la ventana RGL que genera `plot3d`. Ajust√© algunos de los valores de la c√°mara. Sale una vista que conocemos bien los chilangos.

<figure>
    <a href="/assets/images/iztsnap.png"><img src="/assets/images/iztsnap.png" width= "660"></a>
        <figcaption>3D!</figcaption>
</figure>
<br/>

Tambi√©n se ve bien la vista superior que resulta de `plot_map()` 

{% highlight r %}
# en 2D
(test_c_arr / 255) %>%
  add_shadow(ray_layer) %>%
  add_shadow(ambient_layer, 0) %>%
  plot_map()
{% endhighlight %}

<figure>
    <a href="/assets/images/2dmap.png"><img src="/assets/images/2dmap.png"></a>
        <figcaption>2D</figcaption>
</figure>
<br/>

Finalmente, podemos a√±adir elementos con `rayrender` antes de exportar im√°genes de alta resoluci√≥n con `render_highquality()`. Me gust√≥ esta alternativa para darle m√°s ambiente a la escena con el argumento `light = FALSE` y una esfera de luz de color colocada en donde nos guste m√°s.


<blockquote class="twitter-tweet" data-conversation="none" data-dnt="true"><p lang="en" dir="ltr">Turn off the lights and add your ownü§ì: <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> <a href="https://twitter.com/hashtag/rayshader?src=hash&amp;ref_src=twsrc%5Etfw">#rayshader</a> <a href="https://twitter.com/hashtag/rayrender?src=hash&amp;ref_src=twsrc%5Etfw">#rayrender</a><br><br>render_highquality(light = FALSE, scene_elements = sphere(y = 100, radius = 10, material = diffuse(lightintensity = 250, implicit_sample = TRUE))) <a href="https://t.co/g1QDEphZGh">pic.twitter.com/g1QDEphZGh</a></p>&mdash; Tyler Morgan-Wall (@tylermorganwall) <a href="https://twitter.com/tylermorganwall/status/1188505201193488386?ref_src=twsrc%5Etfw">October 27, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br/>
 

{% highlight r %}
# render
render_highquality(
  light = FALSE,
  scene_elements = rayrender::sphere(
    z = 450, y = 100, x = 200, radius = 36,
    material = rayrender::light(
      intensity = 150,
      spotlight_width = 20,
      color = "#ff773d"
    )
  )
)
{% endhighlight %}

Aqu√≠ hay algunos renders que saqu√© con diferentes opciones de c√°mara e iluminaci√≥n.


<figure>
    <a href="/assets/images/3dfinal.png"><img src="/assets/images/3dfinal.png" width= "660"></a>
        <figcaption></figcaption>
</figure>

<figure>
    <a href="/assets/images/3dwide.png"><img src="/assets/images/3dwide.png" width= "660"></a>
        <figcaption></figcaption>
</figure>

<figure>
    <a href="/assets/images/izt3dsh.png"><img src="/assets/images/izt3dsh.png" width= "660"></a>
        <figcaption></figcaption>
</figure>

<figure>
    <a href="/assets/images/xyplt.png"><img src="/assets/images/xyplt.png" width= "660"></a>
        <figcaption></figcaption>
</figure>
<br/>

Los resultados me gustaron bastante, y con todo √©sto ya hasta se pueden hacer animaciones. Esta manera de georeferenciar im√°genes tambi√©n sirve para mapas que hacemos con R base, siempre y cuando el panel ocupe todo el espacio de la imagen. Espero que esta gu√≠a les sirva. Quedo atento a cualquier duda o comentario. Salu-2



